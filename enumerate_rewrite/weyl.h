#ifndef WEYL_H
#define WEYL_H

#include <inttypes.h>

struct _simple_type;
struct _semisimple_type;
struct _weylgroup_element;
struct _weylgroup;
struct _doublecoset;
struct _doublecoset_list;
struct _doublequotient;

typedef uint64_t weylid_t;
typedef struct _simple_type simple_type_t;
typedef struct _semisimple_type semisimple_type_t;
typedef struct _weylgroup_element weylgroup_element_t;
typedef struct _weylgroup weylgroup_t;
typedef struct _doublecoset doublecoset_t;
typedef struct _doublecoset_list doublecoset_list_t;
typedef struct _doublequotient doublequotient_t;

/***************************** structures *******************************/

struct _simple_type {
  char series;
  int rank;
};

struct _semisimple_type {
  int n;
  simple_type_t *factors;
};

struct _weylgroup_element {
  int *word;
  int wordlength;
  weylgroup_element_t **left;
  weylgroup_element_t **right;
  weylgroup_element_t *opposite;
  int is_root_reflection;         // boolean value
  weylid_t id;                    // a unique id
  int index;

  // only set if quotient is generated
  doublecoset_t *coset;
};

struct _weylgroup {
  semisimple_type_t type;
  weylgroup_element_t *elements;
  weylgroup_element_t **lists;
  int *letters;
};

struct _doublecoset {
  doublecoset_list_t *bruhat_lower;
  doublecoset_list_t *bruhat_higher;
  doublecoset_t *opposite;
  weylgroup_element_t *max;
  weylgroup_element_t *min;
  int index;
};

struct _doublecoset_list {
  doublecoset_t *to;
  doublecoset_list_t *next;
};

struct _doublequotient {
  semisimple_type_t type;
  int left_invariance;                // bitmask with rank bits
  int right_invariance;
  int count;                          // number of double cosets
  doublecoset_t *cosets;
  weylgroup_element_t *group;
  doublecoset_list_t *lists;          // only for memory allocation / freeing
  weylgroup_element_t **grouplists;   // only for memory allocation / freeing
  int *groupletters;                  // only for memory allocation / freeing
};

/***************************** functions **************************************/

/* query some basic information on root systems / Weyl groups */

// the rank
int weyl_rank(semisimple_type_t type);

// the order of the weyl group
int weyl_order(semisimple_type_t type);

// the number of reduced positive roots
int weyl_positive(semisimple_type_t type);

// the Cartan matrix (has rank columns and rank rows)
void weyl_cartan_matrix(semisimple_type_t type, int *m);

// the opposition involution as a map from simple roots to simple roots (indexed from 0 to rank-1)
int weyl_opposition(semisimple_type_t type, int simple_root);

/* generate the Weyl group:
   weyl_destroy() has to be used to free memory
 */
weylgroup_t *weyl_generate(semisimple_type_t type);
void weyl_destroy(weylgroup_t *group);

/* generate a double quotient of the Weyl group and its Bruhat order:
   left_invariance and right_invariance are bitmaps specifying a subset of the simple roots
   The Weyl group will be quotiented from the left and right by the subgroups generated by these simple root reflections
   weyl_destroy_bruhat() has to be used to free memory
 */
doublequotient_t *weyl_generate_bruhat(semisimple_type_t type, int left_invariance, int right_invariance);
void weyl_destroy_bruhat(doublequotient_t *dq);

#endif
