import sys
import utils

def e_swap(s,start=0):
    "Returns a string (or indexable object) with the first two letters in start:end-1 reversed"
    return bcd_swap(s,start+1,start+3)

def bcd_swap(s,start=0,end=0):
    "Returns a string (or indexable object) with the interval start:end-1 reversed"
    if start == 0:
        return s[0:start] + s[end-1::-1] + s[end:]
    else:
        return s[0:start] + s[end-1:start-1:-1] + s[end:]

def alphabet_transform(W, alphabet=None):
    "Returns an alphabet transformed to translate from the enumerate to the sage convention"
    if alphabet is None:
        alphabet = "abcdefghijklmnopqrstuvwxyz"
    start = 0
    end = 0
    type = W.cartan_type()
    try:
        t,n = type
        end += n
        if t in ["B","C","D"]:
            alphabet=bcd_swap(alphabet,start,end)
        elif t == "E":
            alphabet=e_swap(alphabet,start)
        return alphabet
    except:
        cartan = type.component_types()
        for t,n in cartan:
            end += n
            if t in ["B","C","D"]:
                alphabet=bcd_swap(alphabet,start,end)
            elif t == "E":
                alphabet=e_swap(alphabet,start)
            start += n
        return alphabet

def ab_to_s1s2(W, s):
    """Converts a Dumas-stecker string (e.g. ab) to a sage Weyl group element (e.g. s1*s2)"""
    alphabet = alphabet_transform(W)
    gens = W.simple_reflections()
    word = W.one()
    if s == "1":
        return word
    for c in s[::-1]:
        word = gens[alphabet.index(c)+1]*word
    return word


def s1s2_to_ab(x):
    """Converts a Weyl group element (e.g. s1*s2) to a Dumas-Stecker string ('ab')"""
    # TODO: Assumes compatible ordering
    W = x.parent()
    alphabet = alphabet_transform(W)
    elt=""
    if x==W.one():
        return "1"
    x = x.__repr__().split("*")
    for g in x:
        n = int(g[1:])
        elt += alphabet[n-1]
    return elt

def principal_ideal(x):
    """Dumas - principal ideal in W generated by x"""
    W = x.parent()
    return W.bruhat_interval(W.one(),x)

def abc_cartan_matrix_comparison(W, d):
    """Compares the permuted Weyl cartan matrix with the one from the data struct d"""
    num_gens = len(W.simple_reflections())
    indices = alphabet_transform(W, [x for x in range(num_gens)])
    sage_matrix = CartanMatrix(W)
    d_matrix = d["cartan_matrix"]
    for orig_i,i in enumerate(indices):
        for orig_j,j in enumerate(indices):
            if sage_matrix[i][j] != d_matrix[orig_i][orig_j]:
                return False
    return True


def print_abc_cartan_matrix(W):
    # alphabet = alphabet_transform(W)
    num_gens = len(W.simple_reflections())
    indices = alphabet_transform(W, [x for x in range(num_gens)])
    orig_matrix = CartanMatrix(W)
    print("Original cartan matrix:")
    print(orig_matrix)
    print("Permuted cartan matrix:")
    matrix = ""
    for i in indices:
        matrix += "["
        for orig_j,j in enumerate(indices):
            m_entry = orig_matrix[i][j]
            if orig_j!=0:
                matrix += " "
            if m_entry<0:
                matrix += str(m_entry)
            else:
                matrix += " " + str(m_entry)
        matrix += "]\n"
    print(matrix)


def union_ideal(I,x):
    """Take the union of an ideal and the principal ideal generated by x."""
    L = principal_ideal(x)
    I.update(L)
    return I

def generating_set(I):
    """Given an ideal I in a Weyl group W, return its minimal generating set."""
    x = next(iter(I))
    W = x.parent()
    gens = W.simple_reflections()
    I_gens = set()
    for x in I:
        is_gen = True
        for g in gens:
            # If g*x or x*g an upper cover and in I, then x is not a bruhat ideal generator of I.
            if g*x in I and (g*x).length() > x.length():
                is_gen = False
                break
            if x*g in I and (x*g).length() > x.length():
                is_gen = False
                break
        if is_gen:
            I_gens.add(x)
    return I_gens
        

def perp(I):
    """Given a Weyl group W and an ideal I, calculates w0*I_C (longest elt times the complement of I)"""
    x = next(iter(I))
    W = x.parent()
    w0 = W.long_element()
    I_C = set(principal_ideal(w0)) - I
    return {w0*x for x in I_C}

def complement(I):
    """Returns I_C in the Weyl group W."""
    x = next(iter(I))
    W = x.parent()
    w0 = W.long_element()
    return set(principal_ideal(w0)) - I

def x_in_wox(x):
    """Returns true if x in <wo x>"""
    W = x.parent()
    w0 = W.long_element()
    return x in principal_ideal(w0*x)

def print_core_hull(infile):
    d = utils.load_json_data(infile)
    cartan = d["summands"]
    G = WeylGroup(cartan, "s")# * WeylGroup(cartan, "s")
    if "cartan_matrix" in d:
        if abc_cartan_matrix_comparison(G,d):
            print("Cartan matrix conversion worked!")
        else:
            print("Ugh, cartan matrix conversion failed")
            exit(1)
    else:
        print("No cartan matrix to compare")
    # print_abc_cartan_matrix(G)
    # exit()
    core = set(principal_ideal(G.long_element()))
    hull = set()
    ideals = d["balanced_ideals"]

    for i in ideals:
        b_set = set()
        for g in i["gen"]:
            word = ab_to_s1s2(G,g)
            b_set = union_ideal(b_set, word)
        core = core.intersection(b_set)
        hull = hull.union(b_set)
    
    print("Size of the core:",len(core))
    print("Size of the hull:",len(hull))
    abc_core = {s1s2_to_ab(sword) for sword in core}
    abc_hull = {s1s2_to_ab(sword) for sword in hull}

    print("Core elements:",abc_core)
    print("Hull elements:",abc_hull)
    abc_coregen = {s1s2_to_ab(sword) for sword in generating_set(core)}
    abc_hullgen = {s1s2_to_ab(sword) for sword in generating_set(hull)}

    print("Core generators:",abc_coregen)
    print("Hull generators:",abc_hullgen)
    core_perp = perp(core)
    hull_perp = perp(hull)
    
    print("Does core-perp=hull?",core_perp == hull)
    print("Does hull-perp=core?",hull_perp == core)
    
    core_condition = [x_in_wox(x) for x in core]
    notcore_condition = [x_in_wox(x) for x in complement(core)]
    print("Does core condition?",all(core_condition))
    print("Does notcore condition?",not any(notcore_condition))

# Actual script starts here...
# TODO: maybe move the functions to utils?

if __name__=="__main__":

    if len(sys.argv) < 2:
        raise TypeError("Requires an input arg, e.g. 'sage intersection.sage A3.json'")

    infile = sys.argv[1]
    print_core_hull(infile)
    # G = WeylGroup(("E7"),"s")
    # print_abc_cartan_matrix(G)
